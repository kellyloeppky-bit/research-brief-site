/**
 * Certificates Routes
 *
 * Certificate API with generation and public verification.
 * Admin-only creation, public verification endpoint.
 */

import { FastifyPluginAsync } from 'fastify';
import { ZodTypeProvider } from 'fastify-type-provider-zod';
import { authenticate } from '../middleware/authenticate.js';
import { requireAuth } from '../middleware/authorize.js';
import { requireHomeOwnership } from '../middleware/require-home-ownership.js';
import {
  createCertificateSchema,
  listCertificatesQuerySchema,
  getCertificateParamsSchema,
  verifyCertificateParamsSchema,
  supersedeCertificateParamsSchema,
  supersedeCertificateSchema,
  type CreateCertificateInput,
  type ListCertificatesQuery,
  type GetCertificateParams,
  type VerifyCertificateParams,
  type SupersedeCertificateParams,
} from '../schemas/certificates.schemas.js';
import { generateCertificateNumber } from '../services/certificate-number.service.js';
import {
  generateVerificationUrl,
  calculateValidUntil,
  isCertificateValid,
} from '../services/certificate-verification.service.js';
import {
  NotFoundError,
  BadRequestError,
  ConflictError,
} from '../lib/errors/http-errors.js';
import type { UserContext } from '../types/auth.types.js';
import { isAdmin } from '../lib/auth/rbac.js';
import { sendCertificateReadyEmail } from '../services/email-notification.service.js';

const certificatesRoutes: FastifyPluginAsync = async (server) => {
  const serverWithTypes = server.withTypeProvider<ZodTypeProvider>();

  /**
   * POST /certificates
   * Generate a new certificate (admin only)
   * Auth: Required (admin)
   */
  serverWithTypes.post(
    '/',
    {
      preHandler: [authenticate, requireAuth('admin')],
      schema: {
        body: createCertificateSchema,
      },
    },
    async (request, reply) => {
      const body = request.body as CreateCertificateInput;

      // Verify result exists
      const result = await server.prisma.result.findUnique({
        where: { id: body.resultId },
        include: {
          testSession: {
            include: {
              kitOrder: true,
            },
          },
          certificate: true,
        },
      });

      if (!result) {
        throw new NotFoundError('Result not found');
      }

      // Check if certificate already exists
      if (result.certificate) {
        throw new ConflictError(
          'A certificate already exists for this result'
        );
      }

      // Verify cert type matches kit type
      const kitTypeMap: Record<string, 'residential' | 'real_estate'> = {
        standard_long: 'residential',
        twin_pack: 'residential',
        real_estate_short: 'real_estate',
      };

      const expectedCertType =
        kitTypeMap[result.testSession.kitOrder.productSku];

      if (body.certType !== expectedCertType) {
        throw new BadRequestError(
          `Certificate type '${body.certType}' does not match product SKU '${result.testSession.kitOrder.productSku}'. Expected '${expectedCertType}'.`
        );
      }

      // Generate certificate number
      const certificateNumber = await generateCertificateNumber(
        server.prisma
      );

      // Calculate dates
      const validFrom = body.validFrom || new Date();
      const validUntil = calculateValidUntil(body.certType, validFrom);

      // Create certificate (ID will be generated by Prisma)
      const certificate = await server.prisma.certificate.create({
        data: {
          resultId: body.resultId,
          homeId: result.testSession.homeId,
          certificateNumber,
          certType: body.certType,
          status: 'valid',
          verificationUrl: '', // Will be updated after creation
          validFrom,
          validUntil,
        },
      });

      // Generate verification URL with the actual certificate ID
      const verificationUrl = generateVerificationUrl(certificate.id);

      // Update certificate with verification URL
      const updatedCertificate = await server.prisma.certificate.update({
        where: { id: certificate.id },
        data: { verificationUrl },
      });

      // Mark result as immutable
      await server.prisma.result.update({
        where: { id: body.resultId },
        data: { isImmutable: true },
      });

      // Send certificate ready email (non-blocking)
      const certificateWithRelations = await server.prisma.certificate.findUnique({
        where: { id: updatedCertificate.id },
        include: {
          home: true,
          result: true,
        },
      });

      if (certificateWithRelations) {
        const homeUserId = certificateWithRelations.home.userId;
        const homeOwner = await server.prisma.user.findUnique({
          where: { id: homeUserId },
        });

        if (homeOwner) {
          // Convert Decimal to number for email template
          const certificateForEmail = {
            ...certificateWithRelations,
            result: {
              valueBqm3: Number(certificateWithRelations.result.valueBqm3),
            },
          };

          sendCertificateReadyEmail(certificateForEmail, homeOwner.email).catch(
            (err) => {
              server.log.error({ err }, 'Failed to send certificate email');
            }
          );
        }
      }

      return reply.status(201).success(updatedCertificate);
    }
  );

  /**
   * GET /certificates
   * List certificates with pagination and filters
   * Auth: Required (self or admin)
   */
  serverWithTypes.get(
    '/',
    {
      preHandler: [authenticate],
      schema: {
        querystring: listCertificatesQuerySchema,
      },
    },
    async (request, reply) => {
      const user = request.user as UserContext;
      const query = request.query as ListCertificatesQuery;

      const page = query.page || 1;
      const limit = query.limit || 10;
      const skip = (page - 1) * limit;

      // Build where clause
      const where: Record<string, unknown> = {};

      // Filter by user unless admin
      if (!isAdmin(user)) {
        where.home = {
          userId: user.id,
        };
      }

      // Apply filters
      if (query.homeId) {
        where.homeId = query.homeId;
      }

      if (query.status) {
        where.status = query.status;
      }

      if (query.certType) {
        where.certType = query.certType;
      }

      // Get total count and data
      const [total, certificates] = await Promise.all([
        server.prisma.certificate.count({ where }),
        server.prisma.certificate.findMany({
          where,
          skip,
          take: limit,
          orderBy: { generatedAt: 'desc' },
          include: {
            result: {
              select: {
                id: true,
                valueBqm3: true,
                zone: true,
              },
            },
            home: {
              select: {
                id: true,
                addressLine1: true,
                city: true,
                province: true,
              },
            },
          },
        }),
      ]);

      return reply.success(certificates, {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      });
    }
  );

  /**
   * GET /certificates/:id
   * Get a specific certificate
   * Auth: Required (home owner or admin)
   */
  serverWithTypes.get(
    '/:id',
    {
      preHandler: [
        authenticate,
        requireHomeOwnership('certificate', async (req) => {
          const { id } = req.params as GetCertificateParams;
          return server.prisma.certificate.findUnique({
            where: { id },
            include: { home: true },
          });
        }),
      ],
      schema: {
        params: getCertificateParamsSchema,
      },
    },
    async (request, reply) => {
      const { id } = request.params as GetCertificateParams;

      const certificate = await server.prisma.certificate.findUnique({
        where: { id },
        include: {
          result: {
            include: {
              testSession: true,
            },
          },
          home: true,
        },
      });

      if (!certificate) {
        throw new NotFoundError('Certificate not found');
      }

      return reply.success(certificate);
    }
  );

  /**
   * GET /certificates/verify/:id
   * Verify certificate (public endpoint, no authentication required)
   * Returns limited public information
   */
  serverWithTypes.get(
    '/verify/:id',
    {
      schema: {
        params: verifyCertificateParamsSchema,
      },
    },
    async (request, reply) => {
      const { id } = request.params as VerifyCertificateParams;

      const certificate = await server.prisma.certificate.findUnique({
        where: { id },
        include: {
          result: {
            select: {
              valueBqm3: true,
              zone: true,
              recordedAt: true,
            },
          },
          home: {
            select: {
              addressLine1: true,
              city: true,
              province: true,
              postalCode: true,
            },
          },
        },
      });

      if (!certificate) {
        throw new NotFoundError('Certificate not found');
      }

      // Calculate if certificate is valid
      const isValid = isCertificateValid(
        certificate.status,
        certificate.validUntil
      );

      // Return public certificate data (limited information)
      return reply.success({
        certificateNumber: certificate.certificateNumber,
        certType: certificate.certType,
        status: certificate.status,
        validFrom: certificate.validFrom,
        validUntil: certificate.validUntil,
        isValid,
        generatedAt: certificate.generatedAt,
        address: {
          addressLine1: certificate.home.addressLine1,
          city: certificate.home.city,
          province: certificate.home.province,
          postalCode: certificate.home.postalCode,
        },
        result: {
          valueBqm3: certificate.result.valueBqm3,
          zone: certificate.result.zone,
          recordedAt: certificate.result.recordedAt,
        },
      });
    }
  );

  /**
   * PATCH /certificates/:id/supersede
   * Mark certificate as superseded (admin only)
   * Auth: Required (admin)
   */
  serverWithTypes.patch(
    '/:id/supersede',
    {
      preHandler: [authenticate, requireAuth('admin')],
      schema: {
        params: supersedeCertificateParamsSchema,
        body: supersedeCertificateSchema,
      },
    },
    async (request, reply) => {
      const { id } = request.params as SupersedeCertificateParams;

      // Verify certificate exists
      const existingCertificate = await server.prisma.certificate.findUnique({
        where: { id },
      });

      if (!existingCertificate) {
        throw new NotFoundError('Certificate not found');
      }

      // Check if already superseded
      if (existingCertificate.status === 'superseded') {
        throw new ConflictError('Certificate is already superseded');
      }

      // Update certificate status
      const certificate = await server.prisma.certificate.update({
        where: { id },
        data: {
          status: 'superseded',
          supersededAt: new Date(),
        },
      });

      return reply.success(certificate);
    }
  );
};

export default certificatesRoutes;
